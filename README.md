### goit-algo-hw-09


### Жадібний алгоритм
Жадібний алгоритм працює швидко, оскільки на кожному кроці просто вибирає найбільший доступний номінал. Він має часову складність O(N), де N — кількість доступних номіналів монет. Це робить його дуже ефективним для більшості практичних випадків.
Однак цей метод не завжди знаходить оптимальне рішення. Наприклад, якщо набір монет нестандартний, він може вибрати неправильні номінали.

### Алгоритм динамічного програмування
Метод динамічного програмування гарантує мінімальну кількість монет для заданої суми. Він використовує підхід збереження проміжних результатів, що робить його складність O(S * N), де S — сума, а N — кількість номіналів.
Цей алгоритм більш надійний, особливо коли доступні номінали не дозволяють жадібному методу знайти оптимальне рішення. Однак при великих значеннях суми він може працювати повільніше через необхідність обчислення всіх можливих варіантів.

### Висновки
Жадібний алгоритм швидший і простіший у реалізації, але не завжди знаходить оптимальне рішення.
Алгоритм динамічного програмування забезпечує мінімальну кількість монет, але може бути повільнішим при великих сумах.
У випадку стандартного набору монет [50, 25, 10, 5, 2, 1] жадібний алгоритм працює коректно, тому його можна використовувати в касових системах.
Якщо набір номіналів зміниться або включатиме нестандартні значення, перевагу слід надати методу динамічного програмування.

### Greedy algorithm: {50: 2, 10: 1, 2: 1, 1: 1} Time: 2.86102294921875e-06
### Dynamic programming: {1: 1, 2: 1, 10: 1, 50: 2} Time: 5.2928924560546875e-05
